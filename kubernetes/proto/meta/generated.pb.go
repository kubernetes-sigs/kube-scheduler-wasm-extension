//
//Copyright The Kubernetes Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

// This file was autogenerated by go-to-protobuf. Do not edit it manually!

// Code generated by protoc-gen-go-plugin. DO NOT EDIT.
// versions:
// 	protoc-gen-go-plugin v0.1.0
// 	protoc               v3.21.12
// source: k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto

package v1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	runtime "sigs.k8s.io/kube-scheduler-wasm-extension/kubernetes/proto/runtime"
	_ "sigs.k8s.io/kube-scheduler-wasm-extension/kubernetes/proto/schema"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// APIGroup contains the name, the supported versions, and the preferred version
// of a group.
type APIGroup struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// name is the name of the group.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// versions are the versions supported in this group.
	Versions []*GroupVersionForDiscovery `protobuf:"bytes,2,rep,name=versions" json:"versions,omitempty"`
	// preferredVersion is the version preferred by the API server, which
	// probably is the storage version.
	// +optional
	PreferredVersion *GroupVersionForDiscovery `protobuf:"bytes,3,opt,name=preferredVersion" json:"preferredVersion,omitempty"`
	// a map of client CIDR to server address that is serving this group.
	// This is to help clients reach servers in the most network-efficient way possible.
	// Clients can use the appropriate server address as per the CIDR that they match.
	// In case of multiple matches, clients should use the longest matching CIDR.
	// The server returns only those CIDRs that it thinks that the client can match.
	// For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
	// Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
	// +optional
	ServerAddressByClientCIDRs []*ServerAddressByClientCIDR `protobuf:"bytes,4,rep,name=serverAddressByClientCIDRs" json:"serverAddressByClientCIDRs,omitempty"`
}

func (x *APIGroup) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *APIGroup) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *APIGroup) GetVersions() []*GroupVersionForDiscovery {
	if x != nil {
		return x.Versions
	}
	return nil
}

func (x *APIGroup) GetPreferredVersion() *GroupVersionForDiscovery {
	if x != nil {
		return x.PreferredVersion
	}
	return nil
}

func (x *APIGroup) GetServerAddressByClientCIDRs() []*ServerAddressByClientCIDR {
	if x != nil {
		return x.ServerAddressByClientCIDRs
	}
	return nil
}

// APIGroupList is a list of APIGroup, to allow clients to discover the API at
// /apis.
type APIGroupList struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// groups is a list of APIGroup.
	Groups []*APIGroup `protobuf:"bytes,1,rep,name=groups" json:"groups,omitempty"`
}

func (x *APIGroupList) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *APIGroupList) GetGroups() []*APIGroup {
	if x != nil {
		return x.Groups
	}
	return nil
}

// APIResource specifies the name of a resource and whether it is namespaced.
type APIResource struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// name is the plural name of the resource.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// singularName is the singular name of the resource.  This allows clients to handle plural and singular opaquely.
	// The singularName is more correct for reporting status on a single item and both singular and plural are allowed
	// from the kubectl CLI interface.
	SingularName *string `protobuf:"bytes,6,opt,name=singularName" json:"singularName,omitempty"`
	// namespaced indicates if a resource is namespaced or not.
	Namespaced *bool `protobuf:"varint,2,opt,name=namespaced" json:"namespaced,omitempty"`
	// group is the preferred group of the resource.  Empty implies the group of the containing resource list.
	// For subresources, this may have a different value, for example: Scale".
	Group *string `protobuf:"bytes,8,opt,name=group" json:"group,omitempty"`
	// version is the preferred version of the resource.  Empty implies the version of the containing resource list
	// For subresources, this may have a different value, for example: v1 (while inside a v1beta1 version of the core resource's group)".
	Version *string `protobuf:"bytes,9,opt,name=version" json:"version,omitempty"`
	// kind is the kind for the resource (e.g. 'Foo' is the kind for a resource 'foo')
	Kind *string `protobuf:"bytes,3,opt,name=kind" json:"kind,omitempty"`
	// verbs is a list of supported kube verbs (this includes get, list, watch, create,
	// update, patch, delete, deletecollection, and proxy)
	Verbs *Verbs `protobuf:"bytes,4,opt,name=verbs" json:"verbs,omitempty"`
	// shortNames is a list of suggested short names of the resource.
	ShortNames []string `protobuf:"bytes,5,rep,name=shortNames" json:"shortNames,omitempty"`
	// categories is a list of the grouped resources this resource belongs to (e.g. 'all')
	Categories []string `protobuf:"bytes,7,rep,name=categories" json:"categories,omitempty"`
	// The hash value of the storage version, the version this resource is
	// converted to when written to the data store. Value must be treated
	// as opaque by clients. Only equality comparison on the value is valid.
	// This is an alpha feature and may change or be removed in the future.
	// The field is populated by the apiserver only if the
	// StorageVersionHash feature gate is enabled.
	// This field will remain optional even if it graduates.
	// +optional
	StorageVersionHash *string `protobuf:"bytes,10,opt,name=storageVersionHash" json:"storageVersionHash,omitempty"`
}

func (x *APIResource) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *APIResource) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *APIResource) GetSingularName() string {
	if x != nil && x.SingularName != nil {
		return *x.SingularName
	}
	return ""
}

func (x *APIResource) GetNamespaced() bool {
	if x != nil && x.Namespaced != nil {
		return *x.Namespaced
	}
	return false
}

func (x *APIResource) GetGroup() string {
	if x != nil && x.Group != nil {
		return *x.Group
	}
	return ""
}

func (x *APIResource) GetVersion() string {
	if x != nil && x.Version != nil {
		return *x.Version
	}
	return ""
}

func (x *APIResource) GetKind() string {
	if x != nil && x.Kind != nil {
		return *x.Kind
	}
	return ""
}

func (x *APIResource) GetVerbs() *Verbs {
	if x != nil {
		return x.Verbs
	}
	return nil
}

func (x *APIResource) GetShortNames() []string {
	if x != nil {
		return x.ShortNames
	}
	return nil
}

func (x *APIResource) GetCategories() []string {
	if x != nil {
		return x.Categories
	}
	return nil
}

func (x *APIResource) GetStorageVersionHash() string {
	if x != nil && x.StorageVersionHash != nil {
		return *x.StorageVersionHash
	}
	return ""
}

// APIResourceList is a list of APIResource, it is used to expose the name of the
// resources supported in a specific group and version, and if the resource
// is namespaced.
type APIResourceList struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// groupVersion is the group and version this APIResourceList is for.
	GroupVersion *string `protobuf:"bytes,1,opt,name=groupVersion" json:"groupVersion,omitempty"`
	// resources contains the name of the resources and if they are namespaced.
	Resources []*APIResource `protobuf:"bytes,2,rep,name=resources" json:"resources,omitempty"`
}

func (x *APIResourceList) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *APIResourceList) GetGroupVersion() string {
	if x != nil && x.GroupVersion != nil {
		return *x.GroupVersion
	}
	return ""
}

func (x *APIResourceList) GetResources() []*APIResource {
	if x != nil {
		return x.Resources
	}
	return nil
}

// APIVersions lists the versions that are available, to allow clients to
// discover the API at /api, which is the root path of the legacy v1 API.
//
// +protobuf.options.(gogoproto.goproto_stringer)=false
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
type APIVersions struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// versions are the api versions that are available.
	Versions []string `protobuf:"bytes,1,rep,name=versions" json:"versions,omitempty"`
	// a map of client CIDR to server address that is serving this group.
	// This is to help clients reach servers in the most network-efficient way possible.
	// Clients can use the appropriate server address as per the CIDR that they match.
	// In case of multiple matches, clients should use the longest matching CIDR.
	// The server returns only those CIDRs that it thinks that the client can match.
	// For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
	// Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
	ServerAddressByClientCIDRs []*ServerAddressByClientCIDR `protobuf:"bytes,2,rep,name=serverAddressByClientCIDRs" json:"serverAddressByClientCIDRs,omitempty"`
}

func (x *APIVersions) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *APIVersions) GetVersions() []string {
	if x != nil {
		return x.Versions
	}
	return nil
}

func (x *APIVersions) GetServerAddressByClientCIDRs() []*ServerAddressByClientCIDR {
	if x != nil {
		return x.ServerAddressByClientCIDRs
	}
	return nil
}

// ApplyOptions may be provided when applying an API object.
// FieldManager is required for apply requests.
// ApplyOptions is equivalent to PatchOptions. It is provided as a convenience with documentation
// that speaks specifically to how the options fields relate to apply.
type ApplyOptions struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// When present, indicates that modifications should not be
	// persisted. An invalid or unrecognized dryRun directive will
	// result in an error response and no further processing of the
	// request. Valid values are:
	// - All: all dry run stages will be processed
	// +optional
	DryRun []string `protobuf:"bytes,1,rep,name=dryRun" json:"dryRun,omitempty"`
	// Force is going to "force" Apply requests. It means user will
	// re-acquire conflicting fields owned by other people.
	Force *bool `protobuf:"varint,2,opt,name=force" json:"force,omitempty"`
	// fieldManager is a name associated with the actor or entity
	// that is making these changes. The value must be less than or
	// 128 characters long, and only contain printable characters,
	// as defined by https://golang.org/pkg/unicode/#IsPrint. This
	// field is required.
	FieldManager *string `protobuf:"bytes,3,opt,name=fieldManager" json:"fieldManager,omitempty"`
}

func (x *ApplyOptions) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *ApplyOptions) GetDryRun() []string {
	if x != nil {
		return x.DryRun
	}
	return nil
}

func (x *ApplyOptions) GetForce() bool {
	if x != nil && x.Force != nil {
		return *x.Force
	}
	return false
}

func (x *ApplyOptions) GetFieldManager() string {
	if x != nil && x.FieldManager != nil {
		return *x.FieldManager
	}
	return ""
}

// Condition contains details for one aspect of the current state of this API Resource.
// ---
// This struct is intended for direct use as an array at the field path .status.conditions.  For example,
//
//	type FooStatus struct{
//	    // Represents the observations of a foo's current state.
//	    // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
//	    // +patchMergeKey=type
//	    // +patchStrategy=merge
//	    // +listType=map
//	    // +listMapKey=type
//	    Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
//
//	    // other fields
//	}
type Condition struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// type of condition in CamelCase or in foo.example.com/CamelCase.
	// ---
	// Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
	// useful (see .node.status.conditions), the ability to deconflict is important.
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	// +required
	// +kubebuilder:validation:Required
	// +kubebuilder:validation:Pattern=`^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$`
	// +kubebuilder:validation:MaxLength=316
	Type *string `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
	// status of the condition, one of True, False, Unknown.
	// +required
	// +kubebuilder:validation:Required
	// +kubebuilder:validation:Enum=True;False;Unknown
	Status *string `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	// +optional
	// +kubebuilder:validation:Minimum=0
	ObservedGeneration *int64 `protobuf:"varint,3,opt,name=observedGeneration" json:"observedGeneration,omitempty"`
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	// +required
	// +kubebuilder:validation:Required
	// +kubebuilder:validation:Type=string
	// +kubebuilder:validation:Format=date-time
	LastTransitionTime *Time `protobuf:"bytes,4,opt,name=lastTransitionTime" json:"lastTransitionTime,omitempty"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	// +required
	// +kubebuilder:validation:Required
	// +kubebuilder:validation:MaxLength=1024
	// +kubebuilder:validation:MinLength=1
	// +kubebuilder:validation:Pattern=`^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$`
	Reason *string `protobuf:"bytes,5,opt,name=reason" json:"reason,omitempty"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	// +required
	// +kubebuilder:validation:Required
	// +kubebuilder:validation:MaxLength=32768
	Message *string `protobuf:"bytes,6,opt,name=message" json:"message,omitempty"`
}

func (x *Condition) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *Condition) GetType() string {
	if x != nil && x.Type != nil {
		return *x.Type
	}
	return ""
}

func (x *Condition) GetStatus() string {
	if x != nil && x.Status != nil {
		return *x.Status
	}
	return ""
}

func (x *Condition) GetObservedGeneration() int64 {
	if x != nil && x.ObservedGeneration != nil {
		return *x.ObservedGeneration
	}
	return 0
}

func (x *Condition) GetLastTransitionTime() *Time {
	if x != nil {
		return x.LastTransitionTime
	}
	return nil
}

func (x *Condition) GetReason() string {
	if x != nil && x.Reason != nil {
		return *x.Reason
	}
	return ""
}

func (x *Condition) GetMessage() string {
	if x != nil && x.Message != nil {
		return *x.Message
	}
	return ""
}

// CreateOptions may be provided when creating an API object.
type CreateOptions struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// When present, indicates that modifications should not be
	// persisted. An invalid or unrecognized dryRun directive will
	// result in an error response and no further processing of the
	// request. Valid values are:
	// - All: all dry run stages will be processed
	// +optional
	DryRun []string `protobuf:"bytes,1,rep,name=dryRun" json:"dryRun,omitempty"`
	// fieldManager is a name associated with the actor or entity
	// that is making these changes. The value must be less than or
	// 128 characters long, and only contain printable characters,
	// as defined by https://golang.org/pkg/unicode/#IsPrint.
	// +optional
	FieldManager *string `protobuf:"bytes,3,opt,name=fieldManager" json:"fieldManager,omitempty"`
	// fieldValidation instructs the server on how to handle
	// objects in the request (POST/PUT/PATCH) containing unknown
	// or duplicate fields. Valid values are:
	// - Ignore: This will ignore any unknown fields that are silently
	// dropped from the object, and will ignore all but the last duplicate
	// field that the decoder encounters. This is the default behavior
	// prior to v1.23.
	// - Warn: This will send a warning via the standard warning response
	// header for each unknown field that is dropped from the object, and
	// for each duplicate field that is encountered. The request will
	// still succeed if there are no other errors, and will only persist
	// the last of any duplicate fields. This is the default in v1.23+
	// - Strict: This will fail the request with a BadRequest error if
	// any unknown fields would be dropped from the object, or if any
	// duplicate fields are present. The error returned from the server
	// will contain all unknown and duplicate fields encountered.
	// +optional
	FieldValidation *string `protobuf:"bytes,4,opt,name=fieldValidation" json:"fieldValidation,omitempty"`
}

func (x *CreateOptions) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *CreateOptions) GetDryRun() []string {
	if x != nil {
		return x.DryRun
	}
	return nil
}

func (x *CreateOptions) GetFieldManager() string {
	if x != nil && x.FieldManager != nil {
		return *x.FieldManager
	}
	return ""
}

func (x *CreateOptions) GetFieldValidation() string {
	if x != nil && x.FieldValidation != nil {
		return *x.FieldValidation
	}
	return ""
}

// DeleteOptions may be provided when deleting an API object.
type DeleteOptions struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The duration in seconds before the object should be deleted. Value must be non-negative integer.
	// The value zero indicates delete immediately. If this value is nil, the default grace period for the
	// specified type will be used.
	// Defaults to a per object value if not specified. zero means delete immediately.
	// +optional
	GracePeriodSeconds *int64 `protobuf:"varint,1,opt,name=gracePeriodSeconds" json:"gracePeriodSeconds,omitempty"`
	// Must be fulfilled before a deletion is carried out. If not possible, a 409 Conflict status will be
	// returned.
	// +k8s:conversion-gen=false
	// +optional
	Preconditions *Preconditions `protobuf:"bytes,2,opt,name=preconditions" json:"preconditions,omitempty"`
	// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
	// Should the dependent objects be orphaned. If true/false, the "orphan"
	// finalizer will be added to/removed from the object's finalizers list.
	// Either this field or PropagationPolicy may be set, but not both.
	// +optional
	OrphanDependents *bool `protobuf:"varint,3,opt,name=orphanDependents" json:"orphanDependents,omitempty"`
	// Whether and how garbage collection will be performed.
	// Either this field or OrphanDependents may be set, but not both.
	// The default policy is decided by the existing finalizer set in the
	// metadata.finalizers and the resource-specific default policy.
	// Acceptable values are: 'Orphan' - orphan the dependents; 'Background' -
	// allow the garbage collector to delete the dependents in the background;
	// 'Foreground' - a cascading policy that deletes all dependents in the
	// foreground.
	// +optional
	PropagationPolicy *string `protobuf:"bytes,4,opt,name=propagationPolicy" json:"propagationPolicy,omitempty"`
	// When present, indicates that modifications should not be
	// persisted. An invalid or unrecognized dryRun directive will
	// result in an error response and no further processing of the
	// request. Valid values are:
	// - All: all dry run stages will be processed
	// +optional
	DryRun []string `protobuf:"bytes,5,rep,name=dryRun" json:"dryRun,omitempty"`
}

func (x *DeleteOptions) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *DeleteOptions) GetGracePeriodSeconds() int64 {
	if x != nil && x.GracePeriodSeconds != nil {
		return *x.GracePeriodSeconds
	}
	return 0
}

func (x *DeleteOptions) GetPreconditions() *Preconditions {
	if x != nil {
		return x.Preconditions
	}
	return nil
}

func (x *DeleteOptions) GetOrphanDependents() bool {
	if x != nil && x.OrphanDependents != nil {
		return *x.OrphanDependents
	}
	return false
}

func (x *DeleteOptions) GetPropagationPolicy() string {
	if x != nil && x.PropagationPolicy != nil {
		return *x.PropagationPolicy
	}
	return ""
}

func (x *DeleteOptions) GetDryRun() []string {
	if x != nil {
		return x.DryRun
	}
	return nil
}

// Duration is a wrapper around time.Duration which supports correct
// marshaling to YAML and JSON. In particular, it marshals into strings, which
// can be used as map keys in json.
type Duration struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Duration *int64 `protobuf:"varint,1,opt,name=duration" json:"duration,omitempty"`
}

func (x *Duration) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *Duration) GetDuration() int64 {
	if x != nil && x.Duration != nil {
		return *x.Duration
	}
	return 0
}

// FieldsV1 stores a set of fields in a data structure like a Trie, in JSON format.
//
// Each key is either a '.' representing the field itself, and will always map to an empty set,
// or a string representing a sub-field or item. The string will follow one of these four formats:
// 'f:<name>', where <name> is the name of a field in a struct, or key in a map
// 'v:<value>', where <value> is the exact json formatted value of a list item
// 'i:<index>', where <index> is position of a item in a list
// 'k:<keys>', where <keys> is a map of  a list item's key fields to their unique values
// If a key maps to an empty Fields value, the field that key represents is part of the set.
//
// The exact format is defined in sigs.k8s.io/structured-merge-diff
// +protobuf.options.(gogoproto.goproto_stringer)=false
type FieldsV1 struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Raw is the underlying serialization of this object.
	Raw []byte `protobuf:"bytes,1,opt,name=Raw" json:"Raw,omitempty"`
}

func (x *FieldsV1) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *FieldsV1) GetRaw() []byte {
	if x != nil {
		return x.Raw
	}
	return nil
}

// GetOptions is the standard query options to the standard REST get call.
type GetOptions struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// resourceVersion sets a constraint on what resource versions a request may be served from.
	// See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
	// details.
	//
	// Defaults to unset
	// +optional
	ResourceVersion *string `protobuf:"bytes,1,opt,name=resourceVersion" json:"resourceVersion,omitempty"`
}

func (x *GetOptions) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *GetOptions) GetResourceVersion() string {
	if x != nil && x.ResourceVersion != nil {
		return *x.ResourceVersion
	}
	return ""
}

// GroupKind specifies a Group and a Kind, but does not force a version.  This is useful for identifying
// concepts during lookup stages without having partially valid types
//
// +protobuf.options.(gogoproto.goproto_stringer)=false
type GroupKind struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Group *string `protobuf:"bytes,1,opt,name=group" json:"group,omitempty"`
	Kind  *string `protobuf:"bytes,2,opt,name=kind" json:"kind,omitempty"`
}

func (x *GroupKind) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *GroupKind) GetGroup() string {
	if x != nil && x.Group != nil {
		return *x.Group
	}
	return ""
}

func (x *GroupKind) GetKind() string {
	if x != nil && x.Kind != nil {
		return *x.Kind
	}
	return ""
}

// GroupResource specifies a Group and a Resource, but does not force a version.  This is useful for identifying
// concepts during lookup stages without having partially valid types
//
// +protobuf.options.(gogoproto.goproto_stringer)=false
type GroupResource struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Group    *string `protobuf:"bytes,1,opt,name=group" json:"group,omitempty"`
	Resource *string `protobuf:"bytes,2,opt,name=resource" json:"resource,omitempty"`
}

func (x *GroupResource) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *GroupResource) GetGroup() string {
	if x != nil && x.Group != nil {
		return *x.Group
	}
	return ""
}

func (x *GroupResource) GetResource() string {
	if x != nil && x.Resource != nil {
		return *x.Resource
	}
	return ""
}

// GroupVersion contains the "group" and the "version", which uniquely identifies the API.
//
// +protobuf.options.(gogoproto.goproto_stringer)=false
type GroupVersion struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Group   *string `protobuf:"bytes,1,opt,name=group" json:"group,omitempty"`
	Version *string `protobuf:"bytes,2,opt,name=version" json:"version,omitempty"`
}

func (x *GroupVersion) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *GroupVersion) GetGroup() string {
	if x != nil && x.Group != nil {
		return *x.Group
	}
	return ""
}

func (x *GroupVersion) GetVersion() string {
	if x != nil && x.Version != nil {
		return *x.Version
	}
	return ""
}

// GroupVersion contains the "group/version" and "version" string of a version.
// It is made a struct to keep extensibility.
type GroupVersionForDiscovery struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// groupVersion specifies the API group and version in the form "group/version"
	GroupVersion *string `protobuf:"bytes,1,opt,name=groupVersion" json:"groupVersion,omitempty"`
	// version specifies the version in the form of "version". This is to save
	// the clients the trouble of splitting the GroupVersion.
	Version *string `protobuf:"bytes,2,opt,name=version" json:"version,omitempty"`
}

func (x *GroupVersionForDiscovery) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *GroupVersionForDiscovery) GetGroupVersion() string {
	if x != nil && x.GroupVersion != nil {
		return *x.GroupVersion
	}
	return ""
}

func (x *GroupVersionForDiscovery) GetVersion() string {
	if x != nil && x.Version != nil {
		return *x.Version
	}
	return ""
}

// GroupVersionKind unambiguously identifies a kind.  It doesn't anonymously include GroupVersion
// to avoid automatic coercion.  It doesn't use a GroupVersion to avoid custom marshalling
//
// +protobuf.options.(gogoproto.goproto_stringer)=false
type GroupVersionKind struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Group   *string `protobuf:"bytes,1,opt,name=group" json:"group,omitempty"`
	Version *string `protobuf:"bytes,2,opt,name=version" json:"version,omitempty"`
	Kind    *string `protobuf:"bytes,3,opt,name=kind" json:"kind,omitempty"`
}

func (x *GroupVersionKind) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *GroupVersionKind) GetGroup() string {
	if x != nil && x.Group != nil {
		return *x.Group
	}
	return ""
}

func (x *GroupVersionKind) GetVersion() string {
	if x != nil && x.Version != nil {
		return *x.Version
	}
	return ""
}

func (x *GroupVersionKind) GetKind() string {
	if x != nil && x.Kind != nil {
		return *x.Kind
	}
	return ""
}

// GroupVersionResource unambiguously identifies a resource.  It doesn't anonymously include GroupVersion
// to avoid automatic coercion.  It doesn't use a GroupVersion to avoid custom marshalling
//
// +protobuf.options.(gogoproto.goproto_stringer)=false
type GroupVersionResource struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Group    *string `protobuf:"bytes,1,opt,name=group" json:"group,omitempty"`
	Version  *string `protobuf:"bytes,2,opt,name=version" json:"version,omitempty"`
	Resource *string `protobuf:"bytes,3,opt,name=resource" json:"resource,omitempty"`
}

func (x *GroupVersionResource) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *GroupVersionResource) GetGroup() string {
	if x != nil && x.Group != nil {
		return *x.Group
	}
	return ""
}

func (x *GroupVersionResource) GetVersion() string {
	if x != nil && x.Version != nil {
		return *x.Version
	}
	return ""
}

func (x *GroupVersionResource) GetResource() string {
	if x != nil && x.Resource != nil {
		return *x.Resource
	}
	return ""
}

// A label selector is a label query over a set of resources. The result of matchLabels and
// matchExpressions are ANDed. An empty label selector matches all objects. A null
// label selector matches no objects.
// +structType=atomic
type LabelSelector struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	// +optional
	MatchLabels map[string]string `protobuf:"bytes,1,rep,name=matchLabels" json:"matchLabels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	// +optional
	MatchExpressions []*LabelSelectorRequirement `protobuf:"bytes,2,rep,name=matchExpressions" json:"matchExpressions,omitempty"`
}

func (x *LabelSelector) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *LabelSelector) GetMatchLabels() map[string]string {
	if x != nil {
		return x.MatchLabels
	}
	return nil
}

func (x *LabelSelector) GetMatchExpressions() []*LabelSelectorRequirement {
	if x != nil {
		return x.MatchExpressions
	}
	return nil
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type LabelSelectorRequirement struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// key is the label key that the selector applies to.
	// +patchMergeKey=key
	// +patchStrategy=merge
	Key *string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator *string `protobuf:"bytes,2,opt,name=operator" json:"operator,omitempty"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	// +optional
	Values []string `protobuf:"bytes,3,rep,name=values" json:"values,omitempty"`
}

func (x *LabelSelectorRequirement) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *LabelSelectorRequirement) GetKey() string {
	if x != nil && x.Key != nil {
		return *x.Key
	}
	return ""
}

func (x *LabelSelectorRequirement) GetOperator() string {
	if x != nil && x.Operator != nil {
		return *x.Operator
	}
	return ""
}

func (x *LabelSelectorRequirement) GetValues() []string {
	if x != nil {
		return x.Values
	}
	return nil
}

// List holds a list of objects, which may not be known by the server.
type List struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Standard list metadata.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	// +optional
	Metadata *ListMeta `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	// List of objects
	Items []*runtime.RawExtension `protobuf:"bytes,2,rep,name=items" json:"items,omitempty"`
}

func (x *List) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *List) GetMetadata() *ListMeta {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *List) GetItems() []*runtime.RawExtension {
	if x != nil {
		return x.Items
	}
	return nil
}

// ListMeta describes metadata that synthetic resources must have, including lists and
// various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
type ListMeta struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
	// +optional
	SelfLink *string `protobuf:"bytes,1,opt,name=selfLink" json:"selfLink,omitempty"`
	// String that identifies the server's internal version of this object that
	// can be used by clients to determine when objects have changed.
	// Value must be treated as opaque by clients and passed unmodified back to the server.
	// Populated by the system.
	// Read-only.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
	// +optional
	ResourceVersion *string `protobuf:"bytes,2,opt,name=resourceVersion" json:"resourceVersion,omitempty"`
	// continue may be set if the user set a limit on the number of items returned, and indicates that
	// the server has more data available. The value is opaque and may be used to issue another request
	// to the endpoint that served this list to retrieve the next set of available objects. Continuing a
	// consistent list may not be possible if the server configuration has changed or more than a few
	// minutes have passed. The resourceVersion field returned when using this continue value will be
	// identical to the value in the first response, unless you have received this token from an error
	// message.
	Continue *string `protobuf:"bytes,3,opt,name=continue" json:"continue,omitempty"`
	// remainingItemCount is the number of subsequent items in the list which are not included in this
	// list response. If the list request contained label or field selectors, then the number of
	// remaining items is unknown and the field will be left unset and omitted during serialization.
	// If the list is complete (either because it is not chunking or because this is the last chunk),
	// then there are no more remaining items and this field will be left unset and omitted during
	// serialization.
	// Servers older than v1.15 do not set this field.
	// The intended use of the remainingItemCount is *estimating* the size of a collection. Clients
	// should not rely on the remainingItemCount to be set or to be exact.
	// +optional
	RemainingItemCount *int64 `protobuf:"varint,4,opt,name=remainingItemCount" json:"remainingItemCount,omitempty"`
}

func (x *ListMeta) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *ListMeta) GetSelfLink() string {
	if x != nil && x.SelfLink != nil {
		return *x.SelfLink
	}
	return ""
}

func (x *ListMeta) GetResourceVersion() string {
	if x != nil && x.ResourceVersion != nil {
		return *x.ResourceVersion
	}
	return ""
}

func (x *ListMeta) GetContinue() string {
	if x != nil && x.Continue != nil {
		return *x.Continue
	}
	return ""
}

func (x *ListMeta) GetRemainingItemCount() int64 {
	if x != nil && x.RemainingItemCount != nil {
		return *x.RemainingItemCount
	}
	return 0
}

// ListOptions is the query options to a standard REST list call.
type ListOptions struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// A selector to restrict the list of returned objects by their labels.
	// Defaults to everything.
	// +optional
	LabelSelector *string `protobuf:"bytes,1,opt,name=labelSelector" json:"labelSelector,omitempty"`
	// A selector to restrict the list of returned objects by their fields.
	// Defaults to everything.
	// +optional
	FieldSelector *string `protobuf:"bytes,2,opt,name=fieldSelector" json:"fieldSelector,omitempty"`
	// Watch for changes to the described resources and return them as a stream of
	// add, update, and remove notifications. Specify resourceVersion.
	// +optional
	Watch *bool `protobuf:"varint,3,opt,name=watch" json:"watch,omitempty"`
	// allowWatchBookmarks requests watch events with type "BOOKMARK".
	// Servers that do not implement bookmarks may ignore this flag and
	// bookmarks are sent at the server's discretion. Clients should not
	// assume bookmarks are returned at any specific interval, nor may they
	// assume the server will send any BOOKMARK event during a session.
	// If this is not a watch, this field is ignored.
	// +optional
	AllowWatchBookmarks *bool `protobuf:"varint,9,opt,name=allowWatchBookmarks" json:"allowWatchBookmarks,omitempty"`
	// resourceVersion sets a constraint on what resource versions a request may be served from.
	// See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
	// details.
	//
	// Defaults to unset
	// +optional
	ResourceVersion *string `protobuf:"bytes,4,opt,name=resourceVersion" json:"resourceVersion,omitempty"`
	// resourceVersionMatch determines how resourceVersion is applied to list calls.
	// It is highly recommended that resourceVersionMatch be set for list calls where
	// resourceVersion is set
	// See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
	// details.
	//
	// Defaults to unset
	// +optional
	ResourceVersionMatch *string `protobuf:"bytes,10,opt,name=resourceVersionMatch" json:"resourceVersionMatch,omitempty"`
	// Timeout for the list/watch call.
	// This limits the duration of the call, regardless of any activity or inactivity.
	// +optional
	TimeoutSeconds *int64 `protobuf:"varint,5,opt,name=timeoutSeconds" json:"timeoutSeconds,omitempty"`
	// limit is a maximum number of responses to return for a list call. If more items exist, the
	// server will set the `continue` field on the list metadata to a value that can be used with the
	// same initial query to retrieve the next set of results. Setting a limit may return fewer than
	// the requested amount of items (up to zero items) in the event all requested objects are
	// filtered out and clients should only use the presence of the continue field to determine whether
	// more results are available. Servers may choose not to support the limit argument and will return
	// all of the available results. If limit is specified and the continue field is empty, clients may
	// assume that no more results are available. This field is not supported if watch is true.
	//
	// The server guarantees that the objects returned when using continue will be identical to issuing
	// a single list call without a limit - that is, no objects created, modified, or deleted after the
	// first request is issued will be included in any subsequent continued requests. This is sometimes
	// referred to as a consistent snapshot, and ensures that a client that is using limit to receive
	// smaller chunks of a very large result can ensure they see all possible objects. If objects are
	// updated during a chunked list the version of the object that was present at the time the first list
	// result was calculated is returned.
	Limit *int64 `protobuf:"varint,7,opt,name=limit" json:"limit,omitempty"`
	// The continue option should be set when retrieving more results from the server. Since this value is
	// server defined, clients may only use the continue value from a previous query result with identical
	// query parameters (except for the value of continue) and the server may reject a continue value it
	// does not recognize. If the specified continue value is no longer valid whether due to expiration
	// (generally five to fifteen minutes) or a configuration change on the server, the server will
	// respond with a 410 ResourceExpired error together with a continue token. If the client needs a
	// consistent list, it must restart their list without the continue field. Otherwise, the client may
	// send another list request with the token received with the 410 error, the server will respond with
	// a list starting from the next key, but from the latest snapshot, which is inconsistent from the
	// previous list results - objects that are created, modified, or deleted after the first list request
	// will be included in the response, as long as their keys are after the "next key".
	//
	// This field is not supported when watch is true. Clients may start a watch from the last
	// resourceVersion value returned by the server and not miss any modifications.
	Continue *string `protobuf:"bytes,8,opt,name=continue" json:"continue,omitempty"`
	// `sendInitialEvents=true` may be set together with `watch=true`.
	// In that case, the watch stream will begin with synthetic events to
	// produce the current state of objects in the collection. Once all such
	// events have been sent, a synthetic "Bookmark" event  will be sent.
	// The bookmark will report the ResourceVersion (RV) corresponding to the
	// set of objects, and be marked with `"k8s.io/initial-events-end": "true"` annotation.
	// Afterwards, the watch stream will proceed as usual, sending watch events
	// corresponding to changes (subsequent to the RV) to objects watched.
	//
	// When `sendInitialEvents` option is set, we require `resourceVersionMatch`
	// option to also be set. The semantic of the watch request is as following:
	//   - `resourceVersionMatch` = NotOlderThan
	//     is interpreted as "data at least as new as the provided `resourceVersion`"
	//     and the bookmark event is send when the state is synced
	//     to a `resourceVersion` at least as fresh as the one provided by the ListOptions.
	//     If `resourceVersion` is unset, this is interpreted as "consistent read" and the
	//     bookmark event is send when the state is synced at least to the moment
	//     when request started being processed.
	//   - `resourceVersionMatch` set to any other value or unset
	//     Invalid error is returned.
	//
	// Defaults to true if `resourceVersion=""` or `resourceVersion="0"` (for backward
	// compatibility reasons) and to false otherwise.
	// +optional
	SendInitialEvents *bool `protobuf:"varint,11,opt,name=sendInitialEvents" json:"sendInitialEvents,omitempty"`
}

func (x *ListOptions) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *ListOptions) GetLabelSelector() string {
	if x != nil && x.LabelSelector != nil {
		return *x.LabelSelector
	}
	return ""
}

func (x *ListOptions) GetFieldSelector() string {
	if x != nil && x.FieldSelector != nil {
		return *x.FieldSelector
	}
	return ""
}

func (x *ListOptions) GetWatch() bool {
	if x != nil && x.Watch != nil {
		return *x.Watch
	}
	return false
}

func (x *ListOptions) GetAllowWatchBookmarks() bool {
	if x != nil && x.AllowWatchBookmarks != nil {
		return *x.AllowWatchBookmarks
	}
	return false
}

func (x *ListOptions) GetResourceVersion() string {
	if x != nil && x.ResourceVersion != nil {
		return *x.ResourceVersion
	}
	return ""
}

func (x *ListOptions) GetResourceVersionMatch() string {
	if x != nil && x.ResourceVersionMatch != nil {
		return *x.ResourceVersionMatch
	}
	return ""
}

func (x *ListOptions) GetTimeoutSeconds() int64 {
	if x != nil && x.TimeoutSeconds != nil {
		return *x.TimeoutSeconds
	}
	return 0
}

func (x *ListOptions) GetLimit() int64 {
	if x != nil && x.Limit != nil {
		return *x.Limit
	}
	return 0
}

func (x *ListOptions) GetContinue() string {
	if x != nil && x.Continue != nil {
		return *x.Continue
	}
	return ""
}

func (x *ListOptions) GetSendInitialEvents() bool {
	if x != nil && x.SendInitialEvents != nil {
		return *x.SendInitialEvents
	}
	return false
}

// ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource
// that the fieldset applies to.
type ManagedFieldsEntry struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Manager is an identifier of the workflow managing these fields.
	Manager *string `protobuf:"bytes,1,opt,name=manager" json:"manager,omitempty"`
	// Operation is the type of operation which lead to this ManagedFieldsEntry being created.
	// The only valid values for this field are 'Apply' and 'Update'.
	Operation *string `protobuf:"bytes,2,opt,name=operation" json:"operation,omitempty"`
	// APIVersion defines the version of this resource that this field set
	// applies to. The format is "group/version" just like the top-level
	// APIVersion field. It is necessary to track the version of a field
	// set because it cannot be automatically converted.
	ApiVersion *string `protobuf:"bytes,3,opt,name=apiVersion" json:"apiVersion,omitempty"`
	// Time is the timestamp of when the ManagedFields entry was added. The
	// timestamp will also be updated if a field is added, the manager
	// changes any of the owned fields value or removes a field. The
	// timestamp does not update when a field is removed from the entry
	// because another manager took it over.
	// +optional
	Time *Time `protobuf:"bytes,4,opt,name=time" json:"time,omitempty"`
	// FieldsType is the discriminator for the different fields format and version.
	// There is currently only one possible value: "FieldsV1"
	FieldsType *string `protobuf:"bytes,6,opt,name=fieldsType" json:"fieldsType,omitempty"`
	// FieldsV1 holds the first JSON version format as described in the "FieldsV1" type.
	// +optional
	FieldsV1 *FieldsV1 `protobuf:"bytes,7,opt,name=fieldsV1" json:"fieldsV1,omitempty"`
	// Subresource is the name of the subresource used to update that object, or
	// empty string if the object was updated through the main resource. The
	// value of this field is used to distinguish between managers, even if they
	// share the same name. For example, a status update will be distinct from a
	// regular update using the same manager name.
	// Note that the APIVersion field is not related to the Subresource field and
	// it always corresponds to the version of the main resource.
	Subresource *string `protobuf:"bytes,8,opt,name=subresource" json:"subresource,omitempty"`
}

func (x *ManagedFieldsEntry) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *ManagedFieldsEntry) GetManager() string {
	if x != nil && x.Manager != nil {
		return *x.Manager
	}
	return ""
}

func (x *ManagedFieldsEntry) GetOperation() string {
	if x != nil && x.Operation != nil {
		return *x.Operation
	}
	return ""
}

func (x *ManagedFieldsEntry) GetApiVersion() string {
	if x != nil && x.ApiVersion != nil {
		return *x.ApiVersion
	}
	return ""
}

func (x *ManagedFieldsEntry) GetTime() *Time {
	if x != nil {
		return x.Time
	}
	return nil
}

func (x *ManagedFieldsEntry) GetFieldsType() string {
	if x != nil && x.FieldsType != nil {
		return *x.FieldsType
	}
	return ""
}

func (x *ManagedFieldsEntry) GetFieldsV1() *FieldsV1 {
	if x != nil {
		return x.FieldsV1
	}
	return nil
}

func (x *ManagedFieldsEntry) GetSubresource() string {
	if x != nil && x.Subresource != nil {
		return *x.Subresource
	}
	return ""
}

// MicroTime is version of Time with microsecond level precision.
//
// +protobuf.options.marshal=false
// +protobuf.as=Timestamp
// +protobuf.options.(gogoproto.goproto_stringer)=false
type MicroTime struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Represents seconds of UTC time since Unix epoch
	// 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
	// 9999-12-31T23:59:59Z inclusive.
	Seconds *int64 `protobuf:"varint,1,opt,name=seconds" json:"seconds,omitempty"`
	// Non-negative fractions of a second at nanosecond resolution. Negative
	// second values with fractions must still have non-negative nanos values
	// that count forward in time. Must be from 0 to 999,999,999
	// inclusive. This field may be limited in precision depending on context.
	Nanos *int32 `protobuf:"varint,2,opt,name=nanos" json:"nanos,omitempty"`
}

func (x *MicroTime) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *MicroTime) GetSeconds() int64 {
	if x != nil && x.Seconds != nil {
		return *x.Seconds
	}
	return 0
}

func (x *MicroTime) GetNanos() int32 {
	if x != nil && x.Nanos != nil {
		return *x.Nanos
	}
	return 0
}

// ObjectMeta is metadata that all persisted resources must have, which includes all objects
// users must create.
type ObjectMeta struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Name must be unique within a namespace. Is required when creating resources, although
	// some resources may allow a client to request the generation of an appropriate name
	// automatically. Name is primarily intended for creation idempotence and configuration
	// definition.
	// Cannot be updated.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
	// +optional
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// GenerateName is an optional prefix, used by the server, to generate a unique
	// name ONLY IF the Name field has not been provided.
	// If this field is used, the name returned to the client will be different
	// than the name passed. This value will also be combined with a unique suffix.
	// The provided value has the same validation rules as the Name field,
	// and may be truncated by the length of the suffix required to make the value
	// unique on the server.
	//
	// If this field is specified and the generated name exists, the server will return a 409.
	//
	// Applied only if Name is not specified.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
	// +optional
	GenerateName *string `protobuf:"bytes,2,opt,name=generateName" json:"generateName,omitempty"`
	// Namespace defines the space within which each name must be unique. An empty namespace is
	// equivalent to the "default" namespace, but "default" is the canonical representation.
	// Not all objects are required to be scoped to a namespace - the value of this field for
	// those objects will be empty.
	//
	// Must be a DNS_LABEL.
	// Cannot be updated.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces
	// +optional
	Namespace *string `protobuf:"bytes,3,opt,name=namespace" json:"namespace,omitempty"`
	// Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
	// +optional
	SelfLink *string `protobuf:"bytes,4,opt,name=selfLink" json:"selfLink,omitempty"`
	// UID is the unique in time and space value for this object. It is typically generated by
	// the server on successful creation of a resource and is not allowed to change on PUT
	// operations.
	//
	// Populated by the system.
	// Read-only.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
	// +optional
	Uid *string `protobuf:"bytes,5,opt,name=uid" json:"uid,omitempty"`
	// An opaque value that represents the internal version of this object that can
	// be used by clients to determine when objects have changed. May be used for optimistic
	// concurrency, change detection, and the watch operation on a resource or set of resources.
	// Clients must treat these values as opaque and passed unmodified back to the server.
	// They may only be valid for a particular resource or set of resources.
	//
	// Populated by the system.
	// Read-only.
	// Value must be treated as opaque by clients and .
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
	// +optional
	ResourceVersion *string `protobuf:"bytes,6,opt,name=resourceVersion" json:"resourceVersion,omitempty"`
	// A sequence number representing a specific generation of the desired state.
	// Populated by the system. Read-only.
	// +optional
	Generation *int64 `protobuf:"varint,7,opt,name=generation" json:"generation,omitempty"`
	// CreationTimestamp is a timestamp representing the server time when this object was
	// created. It is not guaranteed to be set in happens-before order across separate operations.
	// Clients may not set this value. It is represented in RFC3339 form and is in UTC.
	//
	// Populated by the system.
	// Read-only.
	// Null for lists.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	// +optional
	CreationTimestamp *Time `protobuf:"bytes,8,opt,name=creationTimestamp" json:"creationTimestamp,omitempty"`
	// DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
	// field is set by the server when a graceful deletion is requested by the user, and is not
	// directly settable by a client. The resource is expected to be deleted (no longer visible
	// from resource lists, and not reachable by name) after the time in this field, once the
	// finalizers list is empty. As long as the finalizers list contains items, deletion is blocked.
	// Once the deletionTimestamp is set, this value may not be unset or be set further into the
	// future, although it may be shortened or the resource may be deleted prior to this time.
	// For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react
	// by sending a graceful termination signal to the containers in the pod. After that 30 seconds,
	// the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,
	// remove the pod from the API. In the presence of network partitions, this object may still
	// exist after this timestamp, until an administrator or automated process can determine the
	// resource is fully terminated.
	// If not set, graceful deletion of the object has not been requested.
	//
	// Populated by the system when a graceful deletion is requested.
	// Read-only.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	// +optional
	DeletionTimestamp *Time `protobuf:"bytes,9,opt,name=deletionTimestamp" json:"deletionTimestamp,omitempty"`
	// Number of seconds allowed for this object to gracefully terminate before
	// it will be removed from the system. Only set when deletionTimestamp is also set.
	// May only be shortened.
	// Read-only.
	// +optional
	DeletionGracePeriodSeconds *int64 `protobuf:"varint,10,opt,name=deletionGracePeriodSeconds" json:"deletionGracePeriodSeconds,omitempty"`
	// Map of string keys and values that can be used to organize and categorize
	// (scope and select) objects. May match selectors of replication controllers
	// and services.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
	// +optional
	Labels map[string]string `protobuf:"bytes,11,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Annotations is an unstructured key value map stored with a resource that may be
	// set by external tools to store and retrieve arbitrary metadata. They are not
	// queryable and should be preserved when modifying objects.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
	// +optional
	Annotations map[string]string `protobuf:"bytes,12,rep,name=annotations" json:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// List of objects depended by this object. If ALL objects in the list have
	// been deleted, this object will be garbage collected. If this object is managed by a controller,
	// then an entry in this list will point to this controller, with the controller field set to true.
	// There cannot be more than one managing controller.
	// +optional
	// +patchMergeKey=uid
	// +patchStrategy=merge
	OwnerReferences []*OwnerReference `protobuf:"bytes,13,rep,name=ownerReferences" json:"ownerReferences,omitempty"`
	// Must be empty before the object is deleted from the registry. Each entry
	// is an identifier for the responsible component that will remove the entry
	// from the list. If the deletionTimestamp of the object is non-nil, entries
	// in this list can only be removed.
	// Finalizers may be processed and removed in any order.  Order is NOT enforced
	// because it introduces significant risk of stuck finalizers.
	// finalizers is a shared field, any actor with permission can reorder it.
	// If the finalizer list is processed in order, then this can lead to a situation
	// in which the component responsible for the first finalizer in the list is
	// waiting for a signal (field value, external system, or other) produced by a
	// component responsible for a finalizer later in the list, resulting in a deadlock.
	// Without enforced ordering finalizers are free to order amongst themselves and
	// are not vulnerable to ordering changes in the list.
	// +optional
	// +patchStrategy=merge
	Finalizers []string `protobuf:"bytes,14,rep,name=finalizers" json:"finalizers,omitempty"`
	// ManagedFields maps workflow-id and version to the set of fields
	// that are managed by that workflow. This is mostly for internal
	// housekeeping, and users typically shouldn't need to set or
	// understand this field. A workflow can be the user's name, a
	// controller's name, or the name of a specific apply path like
	// "ci-cd". The set of fields is always in the version that the
	// workflow used when modifying the object.
	//
	// +optional
	ManagedFields []*ManagedFieldsEntry `protobuf:"bytes,17,rep,name=managedFields" json:"managedFields,omitempty"`
}

func (x *ObjectMeta) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *ObjectMeta) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *ObjectMeta) GetGenerateName() string {
	if x != nil && x.GenerateName != nil {
		return *x.GenerateName
	}
	return ""
}

func (x *ObjectMeta) GetNamespace() string {
	if x != nil && x.Namespace != nil {
		return *x.Namespace
	}
	return ""
}

func (x *ObjectMeta) GetSelfLink() string {
	if x != nil && x.SelfLink != nil {
		return *x.SelfLink
	}
	return ""
}

func (x *ObjectMeta) GetUid() string {
	if x != nil && x.Uid != nil {
		return *x.Uid
	}
	return ""
}

func (x *ObjectMeta) GetResourceVersion() string {
	if x != nil && x.ResourceVersion != nil {
		return *x.ResourceVersion
	}
	return ""
}

func (x *ObjectMeta) GetGeneration() int64 {
	if x != nil && x.Generation != nil {
		return *x.Generation
	}
	return 0
}

func (x *ObjectMeta) GetCreationTimestamp() *Time {
	if x != nil {
		return x.CreationTimestamp
	}
	return nil
}

func (x *ObjectMeta) GetDeletionTimestamp() *Time {
	if x != nil {
		return x.DeletionTimestamp
	}
	return nil
}

func (x *ObjectMeta) GetDeletionGracePeriodSeconds() int64 {
	if x != nil && x.DeletionGracePeriodSeconds != nil {
		return *x.DeletionGracePeriodSeconds
	}
	return 0
}

func (x *ObjectMeta) GetLabels() map[string]string {
	if x != nil {
		return x.Labels
	}
	return nil
}

func (x *ObjectMeta) GetAnnotations() map[string]string {
	if x != nil {
		return x.Annotations
	}
	return nil
}

func (x *ObjectMeta) GetOwnerReferences() []*OwnerReference {
	if x != nil {
		return x.OwnerReferences
	}
	return nil
}

func (x *ObjectMeta) GetFinalizers() []string {
	if x != nil {
		return x.Finalizers
	}
	return nil
}

func (x *ObjectMeta) GetManagedFields() []*ManagedFieldsEntry {
	if x != nil {
		return x.ManagedFields
	}
	return nil
}

// OwnerReference contains enough information to let you identify an owning
// object. An owning object must be in the same namespace as the dependent, or
// be cluster-scoped, so there is no namespace field.
// +structType=atomic
type OwnerReference struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// API version of the referent.
	ApiVersion *string `protobuf:"bytes,5,opt,name=apiVersion" json:"apiVersion,omitempty"`
	// Kind of the referent.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `protobuf:"bytes,1,opt,name=kind" json:"kind,omitempty"`
	// Name of the referent.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
	Name *string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	// UID of the referent.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
	Uid *string `protobuf:"bytes,4,opt,name=uid" json:"uid,omitempty"`
	// If true, this reference points to the managing controller.
	// +optional
	Controller *bool `protobuf:"varint,6,opt,name=controller" json:"controller,omitempty"`
	// If true, AND if the owner has the "foregroundDeletion" finalizer, then
	// the owner cannot be deleted from the key-value store until this
	// reference is removed.
	// See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion
	// for how the garbage collector interacts with this field and enforces the foreground deletion.
	// Defaults to false.
	// To set this field, a user needs "delete" permission of the owner,
	// otherwise 422 (Unprocessable Entity) will be returned.
	// +optional
	BlockOwnerDeletion *bool `protobuf:"varint,7,opt,name=blockOwnerDeletion" json:"blockOwnerDeletion,omitempty"`
}

func (x *OwnerReference) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *OwnerReference) GetApiVersion() string {
	if x != nil && x.ApiVersion != nil {
		return *x.ApiVersion
	}
	return ""
}

func (x *OwnerReference) GetKind() string {
	if x != nil && x.Kind != nil {
		return *x.Kind
	}
	return ""
}

func (x *OwnerReference) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *OwnerReference) GetUid() string {
	if x != nil && x.Uid != nil {
		return *x.Uid
	}
	return ""
}

func (x *OwnerReference) GetController() bool {
	if x != nil && x.Controller != nil {
		return *x.Controller
	}
	return false
}

func (x *OwnerReference) GetBlockOwnerDeletion() bool {
	if x != nil && x.BlockOwnerDeletion != nil {
		return *x.BlockOwnerDeletion
	}
	return false
}

// PartialObjectMetadata is a generic representation of any object with ObjectMeta. It allows clients
// to get access to a particular ObjectMeta schema without knowing the details of the version.
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
type PartialObjectMetadata struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Standard object's metadata.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	// +optional
	Metadata *ObjectMeta `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
}

func (x *PartialObjectMetadata) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *PartialObjectMetadata) GetMetadata() *ObjectMeta {
	if x != nil {
		return x.Metadata
	}
	return nil
}

// PartialObjectMetadataList contains a list of objects containing only their metadata
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
type PartialObjectMetadataList struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Standard list metadata.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	// +optional
	Metadata *ListMeta `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	// items contains each of the included items.
	Items []*PartialObjectMetadata `protobuf:"bytes,2,rep,name=items" json:"items,omitempty"`
}

func (x *PartialObjectMetadataList) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *PartialObjectMetadataList) GetMetadata() *ListMeta {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *PartialObjectMetadataList) GetItems() []*PartialObjectMetadata {
	if x != nil {
		return x.Items
	}
	return nil
}

// Patch is provided to give a concrete name and type to the Kubernetes PATCH request body.
type Patch struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *Patch) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

// PatchOptions may be provided when patching an API object.
// PatchOptions is meant to be a superset of UpdateOptions.
type PatchOptions struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// When present, indicates that modifications should not be
	// persisted. An invalid or unrecognized dryRun directive will
	// result in an error response and no further processing of the
	// request. Valid values are:
	// - All: all dry run stages will be processed
	// +optional
	DryRun []string `protobuf:"bytes,1,rep,name=dryRun" json:"dryRun,omitempty"`
	// Force is going to "force" Apply requests. It means user will
	// re-acquire conflicting fields owned by other people. Force
	// flag must be unset for non-apply patch requests.
	// +optional
	Force *bool `protobuf:"varint,2,opt,name=force" json:"force,omitempty"`
	// fieldManager is a name associated with the actor or entity
	// that is making these changes. The value must be less than or
	// 128 characters long, and only contain printable characters,
	// as defined by https://golang.org/pkg/unicode/#IsPrint. This
	// field is required for apply requests
	// (application/apply-patch) but optional for non-apply patch
	// types (JsonPatch, MergePatch, StrategicMergePatch).
	// +optional
	FieldManager *string `protobuf:"bytes,3,opt,name=fieldManager" json:"fieldManager,omitempty"`
	// fieldValidation instructs the server on how to handle
	// objects in the request (POST/PUT/PATCH) containing unknown
	// or duplicate fields. Valid values are:
	// - Ignore: This will ignore any unknown fields that are silently
	// dropped from the object, and will ignore all but the last duplicate
	// field that the decoder encounters. This is the default behavior
	// prior to v1.23.
	// - Warn: This will send a warning via the standard warning response
	// header for each unknown field that is dropped from the object, and
	// for each duplicate field that is encountered. The request will
	// still succeed if there are no other errors, and will only persist
	// the last of any duplicate fields. This is the default in v1.23+
	// - Strict: This will fail the request with a BadRequest error if
	// any unknown fields would be dropped from the object, or if any
	// duplicate fields are present. The error returned from the server
	// will contain all unknown and duplicate fields encountered.
	// +optional
	FieldValidation *string `protobuf:"bytes,4,opt,name=fieldValidation" json:"fieldValidation,omitempty"`
}

func (x *PatchOptions) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *PatchOptions) GetDryRun() []string {
	if x != nil {
		return x.DryRun
	}
	return nil
}

func (x *PatchOptions) GetForce() bool {
	if x != nil && x.Force != nil {
		return *x.Force
	}
	return false
}

func (x *PatchOptions) GetFieldManager() string {
	if x != nil && x.FieldManager != nil {
		return *x.FieldManager
	}
	return ""
}

func (x *PatchOptions) GetFieldValidation() string {
	if x != nil && x.FieldValidation != nil {
		return *x.FieldValidation
	}
	return ""
}

// Preconditions must be fulfilled before an operation (update, delete, etc.) is carried out.
type Preconditions struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Specifies the target UID.
	// +optional
	Uid *string `protobuf:"bytes,1,opt,name=uid" json:"uid,omitempty"`
	// Specifies the target ResourceVersion
	// +optional
	ResourceVersion *string `protobuf:"bytes,2,opt,name=resourceVersion" json:"resourceVersion,omitempty"`
}

func (x *Preconditions) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *Preconditions) GetUid() string {
	if x != nil && x.Uid != nil {
		return *x.Uid
	}
	return ""
}

func (x *Preconditions) GetResourceVersion() string {
	if x != nil && x.ResourceVersion != nil {
		return *x.ResourceVersion
	}
	return ""
}

// RootPaths lists the paths available at root.
// For example: "/healthz", "/apis".
type RootPaths struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// paths are the paths available at root.
	Paths []string `protobuf:"bytes,1,rep,name=paths" json:"paths,omitempty"`
}

func (x *RootPaths) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *RootPaths) GetPaths() []string {
	if x != nil {
		return x.Paths
	}
	return nil
}

// ServerAddressByClientCIDR helps the client to determine the server address that they should use, depending on the clientCIDR that they match.
type ServerAddressByClientCIDR struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The CIDR with which clients can match their IP to figure out the server address that they should use.
	ClientCIDR *string `protobuf:"bytes,1,opt,name=clientCIDR" json:"clientCIDR,omitempty"`
	// Address of this server, suitable for a client that matches the above CIDR.
	// This can be a hostname, hostname:port, IP or IP:port.
	ServerAddress *string `protobuf:"bytes,2,opt,name=serverAddress" json:"serverAddress,omitempty"`
}

func (x *ServerAddressByClientCIDR) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *ServerAddressByClientCIDR) GetClientCIDR() string {
	if x != nil && x.ClientCIDR != nil {
		return *x.ClientCIDR
	}
	return ""
}

func (x *ServerAddressByClientCIDR) GetServerAddress() string {
	if x != nil && x.ServerAddress != nil {
		return *x.ServerAddress
	}
	return ""
}

// Status is a return value for calls that don't return other objects.
type Status struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Standard list metadata.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	// +optional
	Metadata *ListMeta `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	// Status of the operation.
	// One of: "Success" or "Failure".
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	// +optional
	Status *string `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
	// A human-readable description of the status of this operation.
	// +optional
	Message *string `protobuf:"bytes,3,opt,name=message" json:"message,omitempty"`
	// A machine-readable description of why this operation is in the
	// "Failure" status. If this value is empty there
	// is no information available. A Reason clarifies an HTTP status
	// code but does not override it.
	// +optional
	Reason *string `protobuf:"bytes,4,opt,name=reason" json:"reason,omitempty"`
	// Extended data associated with the reason.  Each reason may define its
	// own extended details. This field is optional and the data returned
	// is not guaranteed to conform to any schema except that defined by
	// the reason type.
	// +optional
	Details *StatusDetails `protobuf:"bytes,5,opt,name=details" json:"details,omitempty"`
	// Suggested HTTP return code for this status, 0 if not set.
	// +optional
	Code *int32 `protobuf:"varint,6,opt,name=code" json:"code,omitempty"`
}

func (x *Status) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *Status) GetMetadata() *ListMeta {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *Status) GetStatus() string {
	if x != nil && x.Status != nil {
		return *x.Status
	}
	return ""
}

func (x *Status) GetMessage() string {
	if x != nil && x.Message != nil {
		return *x.Message
	}
	return ""
}

func (x *Status) GetReason() string {
	if x != nil && x.Reason != nil {
		return *x.Reason
	}
	return ""
}

func (x *Status) GetDetails() *StatusDetails {
	if x != nil {
		return x.Details
	}
	return nil
}

func (x *Status) GetCode() int32 {
	if x != nil && x.Code != nil {
		return *x.Code
	}
	return 0
}

// StatusCause provides more information about an api.Status failure, including
// cases when multiple errors are encountered.
type StatusCause struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// A machine-readable description of the cause of the error. If this value is
	// empty there is no information available.
	// +optional
	Reason *string `protobuf:"bytes,1,opt,name=reason" json:"reason,omitempty"`
	// A human-readable description of the cause of the error.  This field may be
	// presented as-is to a reader.
	// +optional
	Message *string `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
	// The field of the resource that has caused this error, as named by its JSON
	// serialization. May include dot and postfix notation for nested attributes.
	// Arrays are zero-indexed.  Fields may appear more than once in an array of
	// causes due to fields having multiple errors.
	// Optional.
	//
	// Examples:
	//
	//	"name" - the field "name" on the current resource
	//	"items[0].name" - the field "name" on the first array entry in "items"
	//
	// +optional
	Field *string `protobuf:"bytes,3,opt,name=field" json:"field,omitempty"`
}

func (x *StatusCause) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *StatusCause) GetReason() string {
	if x != nil && x.Reason != nil {
		return *x.Reason
	}
	return ""
}

func (x *StatusCause) GetMessage() string {
	if x != nil && x.Message != nil {
		return *x.Message
	}
	return ""
}

func (x *StatusCause) GetField() string {
	if x != nil && x.Field != nil {
		return *x.Field
	}
	return ""
}

// StatusDetails is a set of additional properties that MAY be set by the
// server to provide additional information about a response. The Reason
// field of a Status object defines what attributes will be set. Clients
// must ignore fields that do not match the defined type of each attribute,
// and should assume that any attribute may be empty, invalid, or under
// defined.
type StatusDetails struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The name attribute of the resource associated with the status StatusReason
	// (when there is a single name which can be described).
	// +optional
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The group attribute of the resource associated with the status StatusReason.
	// +optional
	Group *string `protobuf:"bytes,2,opt,name=group" json:"group,omitempty"`
	// The kind attribute of the resource associated with the status StatusReason.
	// On some operations may differ from the requested resource Kind.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	// +optional
	Kind *string `protobuf:"bytes,3,opt,name=kind" json:"kind,omitempty"`
	// UID of the resource.
	// (when there is a single resource which can be described).
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
	// +optional
	Uid *string `protobuf:"bytes,6,opt,name=uid" json:"uid,omitempty"`
	// The Causes array includes more details associated with the StatusReason
	// failure. Not all StatusReasons may provide detailed causes.
	// +optional
	Causes []*StatusCause `protobuf:"bytes,4,rep,name=causes" json:"causes,omitempty"`
	// If specified, the time in seconds before the operation should be retried. Some errors may indicate
	// the client must take an alternate action - for those errors this field may indicate how long to wait
	// before taking the alternate action.
	// +optional
	RetryAfterSeconds *int32 `protobuf:"varint,5,opt,name=retryAfterSeconds" json:"retryAfterSeconds,omitempty"`
}

func (x *StatusDetails) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *StatusDetails) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *StatusDetails) GetGroup() string {
	if x != nil && x.Group != nil {
		return *x.Group
	}
	return ""
}

func (x *StatusDetails) GetKind() string {
	if x != nil && x.Kind != nil {
		return *x.Kind
	}
	return ""
}

func (x *StatusDetails) GetUid() string {
	if x != nil && x.Uid != nil {
		return *x.Uid
	}
	return ""
}

func (x *StatusDetails) GetCauses() []*StatusCause {
	if x != nil {
		return x.Causes
	}
	return nil
}

func (x *StatusDetails) GetRetryAfterSeconds() int32 {
	if x != nil && x.RetryAfterSeconds != nil {
		return *x.RetryAfterSeconds
	}
	return 0
}

// TableOptions are used when a Table is requested by the caller.
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
type TableOptions struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// includeObject decides whether to include each object along with its columnar information.
	// Specifying "None" will return no object, specifying "Object" will return the full object contents, and
	// specifying "Metadata" (the default) will return the object's metadata in the PartialObjectMetadata kind
	// in version v1beta1 of the meta.k8s.io API group.
	IncludeObject *string `protobuf:"bytes,1,opt,name=includeObject" json:"includeObject,omitempty"`
}

func (x *TableOptions) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *TableOptions) GetIncludeObject() string {
	if x != nil && x.IncludeObject != nil {
		return *x.IncludeObject
	}
	return ""
}

// Time is a wrapper around time.Time which supports correct
// marshaling to YAML and JSON.  Wrappers are provided for many
// of the factory methods that the time package offers.
//
// +protobuf.options.marshal=false
// +protobuf.as=Timestamp
// +protobuf.options.(gogoproto.goproto_stringer)=false
type Time struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Represents seconds of UTC time since Unix epoch
	// 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
	// 9999-12-31T23:59:59Z inclusive.
	Seconds *int64 `protobuf:"varint,1,opt,name=seconds" json:"seconds,omitempty"`
	// Non-negative fractions of a second at nanosecond resolution. Negative
	// second values with fractions must still have non-negative nanos values
	// that count forward in time. Must be from 0 to 999,999,999
	// inclusive. This field may be limited in precision depending on context.
	Nanos *int32 `protobuf:"varint,2,opt,name=nanos" json:"nanos,omitempty"`
}

func (x *Time) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *Time) GetSeconds() int64 {
	if x != nil && x.Seconds != nil {
		return *x.Seconds
	}
	return 0
}

func (x *Time) GetNanos() int32 {
	if x != nil && x.Nanos != nil {
		return *x.Nanos
	}
	return 0
}

// Timestamp is a struct that is equivalent to Time, but intended for
// protobuf marshalling/unmarshalling. It is generated into a serialization
// that matches Time. Do not use in Go structs.
type Timestamp struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Represents seconds of UTC time since Unix epoch
	// 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
	// 9999-12-31T23:59:59Z inclusive.
	Seconds *int64 `protobuf:"varint,1,opt,name=seconds" json:"seconds,omitempty"`
	// Non-negative fractions of a second at nanosecond resolution. Negative
	// second values with fractions must still have non-negative nanos values
	// that count forward in time. Must be from 0 to 999,999,999
	// inclusive. This field may be limited in precision depending on context.
	Nanos *int32 `protobuf:"varint,2,opt,name=nanos" json:"nanos,omitempty"`
}

func (x *Timestamp) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *Timestamp) GetSeconds() int64 {
	if x != nil && x.Seconds != nil {
		return *x.Seconds
	}
	return 0
}

func (x *Timestamp) GetNanos() int32 {
	if x != nil && x.Nanos != nil {
		return *x.Nanos
	}
	return 0
}

// TypeMeta describes an individual object in an API response or request
// with strings representing the type of the object and its API schema version.
// Structures that are versioned or persisted should inline TypeMeta.
//
// +k8s:deepcopy-gen=false
type TypeMeta struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Kind is a string value representing the REST resource this object represents.
	// Servers may infer this from the endpoint the client submits requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	// +optional
	Kind *string `protobuf:"bytes,1,opt,name=kind" json:"kind,omitempty"`
	// APIVersion defines the versioned schema of this representation of an object.
	// Servers should convert recognized schemas to the latest internal value, and
	// may reject unrecognized values.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	// +optional
	ApiVersion *string `protobuf:"bytes,2,opt,name=apiVersion" json:"apiVersion,omitempty"`
}

func (x *TypeMeta) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *TypeMeta) GetKind() string {
	if x != nil && x.Kind != nil {
		return *x.Kind
	}
	return ""
}

func (x *TypeMeta) GetApiVersion() string {
	if x != nil && x.ApiVersion != nil {
		return *x.ApiVersion
	}
	return ""
}

// UpdateOptions may be provided when updating an API object.
// All fields in UpdateOptions should also be present in PatchOptions.
type UpdateOptions struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// When present, indicates that modifications should not be
	// persisted. An invalid or unrecognized dryRun directive will
	// result in an error response and no further processing of the
	// request. Valid values are:
	// - All: all dry run stages will be processed
	// +optional
	DryRun []string `protobuf:"bytes,1,rep,name=dryRun" json:"dryRun,omitempty"`
	// fieldManager is a name associated with the actor or entity
	// that is making these changes. The value must be less than or
	// 128 characters long, and only contain printable characters,
	// as defined by https://golang.org/pkg/unicode/#IsPrint.
	// +optional
	FieldManager *string `protobuf:"bytes,2,opt,name=fieldManager" json:"fieldManager,omitempty"`
	// fieldValidation instructs the server on how to handle
	// objects in the request (POST/PUT/PATCH) containing unknown
	// or duplicate fields. Valid values are:
	// - Ignore: This will ignore any unknown fields that are silently
	// dropped from the object, and will ignore all but the last duplicate
	// field that the decoder encounters. This is the default behavior
	// prior to v1.23.
	// - Warn: This will send a warning via the standard warning response
	// header for each unknown field that is dropped from the object, and
	// for each duplicate field that is encountered. The request will
	// still succeed if there are no other errors, and will only persist
	// the last of any duplicate fields. This is the default in v1.23+
	// - Strict: This will fail the request with a BadRequest error if
	// any unknown fields would be dropped from the object, or if any
	// duplicate fields are present. The error returned from the server
	// will contain all unknown and duplicate fields encountered.
	// +optional
	FieldValidation *string `protobuf:"bytes,3,opt,name=fieldValidation" json:"fieldValidation,omitempty"`
}

func (x *UpdateOptions) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *UpdateOptions) GetDryRun() []string {
	if x != nil {
		return x.DryRun
	}
	return nil
}

func (x *UpdateOptions) GetFieldManager() string {
	if x != nil && x.FieldManager != nil {
		return *x.FieldManager
	}
	return ""
}

func (x *UpdateOptions) GetFieldValidation() string {
	if x != nil && x.FieldValidation != nil {
		return *x.FieldValidation
	}
	return ""
}

// Verbs masks the value so protobuf can generate
//
// +protobuf.nullable=true
// +protobuf.options.(gogoproto.goproto_stringer)=false
type Verbs struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Items []string `protobuf:"bytes,1,rep,name=items" json:"items,omitempty"`
}

func (x *Verbs) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *Verbs) GetItems() []string {
	if x != nil {
		return x.Items
	}
	return nil
}

// Event represents a single event to a watched resource.
//
// +protobuf=true
// +k8s:deepcopy-gen=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
type WatchEvent struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Type *string `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
	// Object is:
	//   - If Type is Added or Modified: the new state of the object.
	//   - If Type is Deleted: the state of the object immediately before deletion.
	//   - If Type is Error: *Status is recommended; other types may make sense
	//     depending on context.
	Object *runtime.RawExtension `protobuf:"bytes,2,opt,name=object" json:"object,omitempty"`
}

func (x *WatchEvent) ProtoReflect() protoreflect.Message {
	panic(`not implemented`)
}

func (x *WatchEvent) GetType() string {
	if x != nil && x.Type != nil {
		return *x.Type
	}
	return ""
}

func (x *WatchEvent) GetObject() *runtime.RawExtension {
	if x != nil {
		return x.Object
	}
	return nil
}
